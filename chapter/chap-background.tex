\chapter{研究背景}
\section{测试的传统方法}
\subsection{软件测试的传统验证方法}
随着计算机软件在一些关键领域，例如航空航天、军事武器以及其他对软件可靠性要求极为严格的领域应用越来越广泛，其复杂程度和功能越来越复杂，集成程度也越来越高。2011年7月23日，由于LKD-T1型列控中心设备存在严重设计缺陷和重大安全隐患，在浙江省温州市内，两辆动车追尾，造成大量人员伤亡，这便是由于软件存在问题所酿成的惨剧。在这种情况下，人们对软件的正确性、可靠性、可靠安全性和保密性等可信性质给予了十分的关注，如何在软件的开发和运行中保证软件具有高可信性质也成为软件理论和技术的重要研究方向。

早期的验证方法分成黑盒测试和白盒测试。黑盒测试是指不考虑系统的内部结构，只按照规格说明测试已定义的功能，所以又被成为基于功能的测试。黑盒测试则将系统看成一个黑盒子，只关心系统的输入输出，所以测试方法的重点在于如何从输入域中选择待测的测试用例，而不关心程序具体如何实现。黑盒测试的一般方法主要有：等价类划分（包括有效等价类和无效等价类）、边界值分析（包括有效边界内和边界外）、判定表（系统输入输出的有效组合）、因果图（系统输入输出的制约关系图）。黑盒测试的常用工具为AutoRunner、winrunner。

而白盒测试则把测试对象看做一个打开的盒子，是考虑系统的内部结构，重点测试系统的每一个动作是否符合定义，因此又称为基于结构的测试。白盒覆盖对测试用例的选择主要看是否能达到对系统内部结构的覆盖而不需考虑软件的功能，有不同的逻辑覆盖准则：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、路径覆盖等。白盒测试的主要方法由逻辑驱动、基路测试等等，常用工具为jtest、VcSmith、C++Test等。

后来，随着软件验证领域的不断发展，验证理论也不断产生。又产生了如下几种软件测试方法。

基于模型的测试。测试用例的选择问题可以看做是从庞大的输入、状态组合中，搜寻那些可以发现错误的状态及组合。如果不适用抽象的手段，有效的测试是不可能达到的。模型化的方法被广泛应用于工程领域，模型是系统功能的形式化或半形化的表示，必须支持输入、状态系统组合的系统枚举，虽然不能产生所有的输入、状态组合，但是模型可以帮助实现这一目的。

验收测试。验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接受，它让系统用户决定是否接受系统。它是一项确定用户是否能够满足合同或用户所需求的测试。验收测试一般有三种策略：正式验收、Alpha测试和Beta测试。

错误驱动测试。功能测试仅能测试系统已实现功能的完备性，而对系统缺少的部分无能为力。在用户实际使用的过程中，会有大量的非法输入，此时系统表现如何，是否会崩溃，基于非法操作或错误的测试就是错误驱动测试。

回归测试。回归测试就是一个不断发现测试和不断改正错误的过程。由于程序的复杂性，各个模块及元素（变量、函数、类）之间存在着相关联性，所以对于改正的错误，还要进行在测试。一方面检查此错误是否真的被修改了，另一方面检查此错误修改是否引入了新的错误，这就需要将测过的样例拿来重新进行测试，这就是回归测试。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新版本中再次出现。在我们神经网络测试框架的设计中，便采取了回归测试的思想。

\subsection{编译器的传统测试方法}
编译器作为计算机软件中最基础的软件之一，与操作系统、数据库系统一起被列为构成计算机系统关键性基础设施。而编译器作为任何软件的产生器，它的安全性、可靠性和稳定性更是至关重要，特别是在那些软件的可靠性要求很高的特殊环境里面，我们必须保证编译器编译出来的代码是对程序源代码正确、真实的反应，保证编译器在编译过程中逻辑上正确性以及行为上的透明性。

编译器系统可信验证主要包括两方面，一个是编译器的逻辑正确性，即编译器编译的程序在逻辑上符合程序源代码的描述，与程序源代码的逻辑一致；另一方面是编译器的安全性和可靠性，这个指编译器在编译过程中不会人为地插入恶意代码，导致目标程序运行不可靠或者达到某些其他恶意的目的。

下面主要介绍编译器的逻辑正确性。

早期的编译器测试主要以人工为主，而后逐渐转向自动测试。自动测试的基本原理为随机生成程序，然后用不同的方式编译出运行等价的程序，然后作对比，具体的做法包括：用两个不同的编译器编译，对比运行结果；用一个编译器的不同优化选项编译，对比运行结果；对原程序中不被运行的语句进行修改，然后和原程序的结果进行对比。

Leroy等人为C语言编译器提出了一种开发编译器以及在开发过程中形式化验证编译器可信性的方法，他们设计了一种叫作Coq proof assistant的工具，在开发编译器过程中验证该编译器是否是正确的。他们的方法侧重于对编译器后端（即中间语言到代码生成过程）的形式化验证，Sandrine等人扩充了Leroy等人的研究，也提出了一种形式化的C语言编译器可信验证方法，该方法支持C语言的一个子集的验证，而且它能够验证编译器的前端过程（即从源代码到中间语言转换过程）的正确性。

如果不能验证整体编译器的正确性，另一种思路则是对每一个编译步骤的正确性进行检查。翻译验证（translation validation）就是一种基于此思路的编译器正确验证方法，其目标是检查每一个编译步骤的结果，将其与源程序比较，检测可能存在的编译错误，该方法绕开了验证编译器整体的复杂性，在每一步验证编译的正确性，这一步骤主要是用于语法层面的测试。另外，还有一种称为可信验证（credible compilation）的技术也是采用类似思路，编译产生转换后的代码的同时，生成额外的上下文信息，使用一个简单的验证器来检查编译步骤的正确性。然而，这些分布验证方法只保证了局部无法顾及整体，还是无法保证编译器本身是没有缺陷的。

\section{神经网络处理器编译器测试框架的必要性}

一般而言，编译器是将一种抽象的高级语言翻译成另一种低级的语言的软件，类似的，神经网络处理器编译器是将一种抽象的神经网络处理器编程语言翻译成底层的神经网络处理器指令序列。同时，通用编译器的编译流程包括：源代码$\rightarrow$预处理器$\rightarrow$编译器$\rightarrow$目标代码$\rightarrow$链接器$\rightarrow$可执行文件。对于编译过程，神经网络处理器编译器与传统编译器类似。但是，由于深度学习指令集的特殊性以及神经网络处理器结构的复杂性，在结构与储存层次方面，神经网络处理器编译器与传统编译器有很多不同。

\subsection{深度学习指令集的特性}
深度学习指令集(Cambricon)的特性主要是以下几点：

1.采用基于负载存储(load-store)访存模式的RISC指令集。具体指令的选取，根据工作负荷(workload)的类型进行计算层面的抽象得出。对于深层神经网络来说，主要的计算和控制任务有几种：向量计算、矩阵计算、标量计算、分支跳转。其中向量计算、矩阵计算、标量计算都属于标准计算工作，形式上和通用处理器没有什么区别，主要的差别在于细节的支撑上，典型的例子就是应用于漏失(drop-out)的随机向量(Random-Vector)指令，用于在一条指令内部为一个向量进行快速随机初始化，以及应用于激活层的指数向量操作（Vector-Expotential），用于在一条指令内部为一个向量进行快速的非线性变换，而分支跳转的逻辑在神经网络计算任务里，并不像常规计算任务那么复杂，所以指令集的设计上并不需要提供丰富的分支跳转逻辑的支持。

2.不引入复杂的Cache体系和相关控制逻辑。这跟机器学习算法的workload类型有强关联，对于机器学习算法来说算法来说，数据逻辑性并不强，Cache对性能的影响不像常规计算任务那么大，所以把用于实现cache hierarchy的控制逻辑精简掉，对于提升芯片的计算功耗比会有很大的助益。

3.使用高速暂存存储器(Scratchpad Memory)而不是寄存器堆来作为计算数据的主存储。因为机器学习算法的计算任务与常规的多媒体计算任务不同，指令所操作的数据长度往往是不定长的，所以应用于多媒体指令优化(SIMD)的寄存器堆就不如Scrathpad Memory灵活。

这些特性使得Cambricon指令集能正确的描述现在大部分的网络，同时，每条指令的描述能力高，对于描述同样的网络来说，所需的指令数量相比通用处理器要少很多。但，这也带来了缺陷，即便是同一条指令，对于不同的参数，指令的生存周期变化很大，且需要访问的存储方位也变化很大，不同类型的指令更是如此，更别说设计不同层次的存储访问。

\subsection{神经网络编译器与传统编译器的比较}
由于深度学习指令集的众多特性，这也使得神经网络编译器与传统编译器有很多不同。

首先，神经网络编译器对应编译的指令粒度较大，对于神经网络处理器来说，一条卷积(Conv)指令可以自己设置卷积核的大小、所需要的卷积图像大小，但是传统处理器的指令操作是固定的，这也给我们的验证带来了很多困难。

其次，神经网络编译器和传统编译器设计的存储层次也有很大不同，传统的编译器中，其计算指令都是针对寄存器的操作，只有load或者store才会涉及到寄存器数据和Cache或者RAM之间的数据交互，但神经网络编译器加入了中间存储这一层，改变了整个编译器的存储层次。

\subsection{使用测试框架带来的好处}
由于神经网络编译器的特殊性，若采用随机指令可能无法覆盖到实际使用需求的指令序列，所以需要实际的使用者，也就是编译器生成的指令来做二次检查，来寻找所有网络集合里那些不易覆盖的“Corner Case”。而测试框架是保证编译器和库这一整套系统正确性的环节，不可或缺。

\section{本节总结}
本节首先介绍了传统软件的测试方法，接着介绍了传统编译器的测试手段，通过分析深度学习指令集的特性，阐明了神经网络处理器编译器与传统编译器的差别，证明了神经网络处理器编译器测试框架的重要性。