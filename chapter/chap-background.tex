\chapter{研究背景}
\section{测试的传统方法}
\subsection{软件测试的传统验证方法}
随着计算机的普及，软件系统已经深入到生活的各个方面，从计算机软件，到智能手机上的各种应用。超市的终端系统，银行的安保系统，甚至航空航天工程的控制系统，软件的应用在各个领域发挥着重要作用。然而，在软件给我们生活带来便利的同时，也存在着风险——软件的实效将会产生严重的后果，2011年7月23日，由于LKD-T1型列控中心设备存在严重设计缺陷和重大安全隐患，在浙江省温州市内，两辆动车追尾，造成大量人员伤亡，这便是由于软件存在问题所酿成的惨剧。在这种情况下，人们对软件的正确性、可靠性、可靠安全性和保密性等可信性质给予了十分的关注，如何在软件的开发和运行中保证软件具有高可信性质也成为软件理论和技术的重要研究方向。

早期的验证方法分成黑盒测试和白盒测试\cite{hetzel1991complete}。

白盒测试是指将测试对象看做一个打开的盒子，是考虑系统的内部结构，重点测试系统的每一个动作是否符合定义，因此被称为基于结构的测试。白盒覆盖对测试用例的选择主要看是否能达到对系统内部结构的覆盖而不需考虑软件的功能，有不同的逻辑覆盖准则：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、路径覆盖等。白盒测试的主要方法由逻辑驱动、基路测试等等，常用工具为jtest、VcSmith、C++Test等。

而黑盒测试则是指不考虑系统的内部结构，只按照规格说明测试已定义的功能，因此被称为基于功能的测试。黑盒测试则系统看成一个黑盒子，只关心系统的输入输出，所以测试方法的重点在于如何从输入域中选择待测的测试用例，而不关心程序具体如何实现。黑盒测试的一般方法主要包括：等价类划分、边界值分析、判定表、因果图。黑盒测试的常用工具为AutoRunner、winrunner。


后来，随着测试验证领域的不断发展，测试理论也不断产生。又产生了如下几种软件测试方法。\cite{许静2003软件测试方法简述与展望}

基于模型的测试。近年来，由于模型化的方法被广泛用于工程领域，因此模型测试的思想被广泛用于软件测试。测试用例的选择问题可以看做是从庞大的输入、状态组合中，搜寻那些可以发现错误的状态及组合。基于模型的测试主要考虑的是系统的功能，因为模型是系统功能的形式化或半形式化的表示，代表了被测系统的本质，因此比起系统来说，更容易被分析。但采取基于模型的测试必须保证模型能够完全准确地展现测试对象的所有特征，而这样的模型不易建立，因此具有一定局限性。

验收测试。验收测试是指系统开发生命周期方法论的一个阶段，是部署软件之前的最后一个测试操作，因此也被称作交付测试。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能及任务。验收测试一般有三种策略：正式验收、非正式测试和Beta测试。

错误驱动测试。错误驱动测试是指，在用户实际使用的过程中，面对用户的非法输入，测试系统的稳定性。功能测试仅能测试系统已实现功能的完备性，而对系统缺少的部分无能为力，因此，需要非法操作或错误的测试来保证系统的稳定性。

回归测试。回归测试就是一个不断发现测试和不断改正错误的过程。由于程序的复杂性，各个模块及元素（变量、函数、类）之间存在着相关联性，所以对于改正的错误，还要进行在测试。一方面检查此错误是否真的被修改了，另一方面检查此错误修改是否引入了新的错误，这就需要将测过的样例拿来重新进行测试，这就是回归测试。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新版本中再次出现。在我们神经网络测试框架的设计中，便采取了回归测试的思想。

\subsection{编译器的传统测试方法}
编译器作为计算机软件中最基础的软件之一，与操作系统、数据库系统一起被列为构成计算机系统关键性基础设施。而编译器作为任何软件的产生器，它的安全性、可靠性和稳定性更是至关重要，特别是在那些软件的可靠性要求很高的特殊环境里面，我们必须保证编译器编译出来的代码是对程序源代码正确、真实的反应，保证编译器在编译过程中逻辑上正确性以及行为上的透明性。

编译器系统可信验证主要包括两方面，一个是编译器的逻辑正确性，即编译器编译的程序在逻辑上符合程序源代码的描述，与程序源代码的逻辑一致；另一方面是编译器的安全性和可靠性，指编译器在编译过程中不会因人为地插入恶意代码，而导致目标程序运行不可靠或者达到某些其他恶意的目的。

下面主要介绍编译器的逻辑正确性。

早期的编译器测试主要以人工为主，而后逐渐转向自动测试\cite{俞甲子2008gcc}。自动测试的基本原理为随机生成程序，然后用不同的方式编译出运行等价的程序，然后作对比，具体的做法包括：用两个不同的编译器编译，对比运行结果；用一个编译器的不同优化选项编译，对比运行结果；对原程序中不被运行的语句进行修改，然后和原程序的结果进行对比。

Leroy等人\cite{hannan1992compiler}为C语言编译器提出了一种开发编译器以及在开发过程中形式化验证编译器可信性的方法，他们设计了一种叫作Coq proof assistant的工具，在开发编译器过程中验证该编译器是否是正确的。他们的方法侧重于对编译器后端（即中间语言到代码生成过程）的形式化验证，Sandrine\cite{berezin2002model}等人扩充了Leroy等人的研究，提出了一种形式化的C语言编译器可信验证方法，该方法支持C语言的一个子集的验证，而且它能够验证编译器的前端过程（即从源代码到中间语言转换过程）的正确性。

如果不能验证整体编译器的正确性，另一种思路则是对每一个编译步骤的正确性进行检查。翻译验证\cite{pnueli1998translation}（translation validation）就是一种基于此思路的编译器正确验证方法，其目标是检查每一个编译步骤的结果，将其与源程序比较，检测可能存在的编译错误，该方法绕开了验证编译器整体的复杂性，在每一步验证编译的正确性，这一步骤主要是用于语法层面的测试。另外，还有一种称为可信验证（credible compilation）\cite{rinard2003credible}的技术也是采用类似思路，编译产生转换后的代码的同时，生成额外的上下文信息，使用一个简单的验证器来检查编译步骤的正确性。然而，这些分布验证方法只保证了局部却无法顾及整体，还是无法保证编译器本身是没有缺陷的。

为了测验神经网络处理器，我们将结合传统测验方法及深度学习指令集的特性进行设计。

\section{神经网络处理器编译器测试框架的特性}

一般而言，编译器是将一种抽象的高级语言翻译成另一种低级的语言的软件，类似的，神经网络处理器编译器是将一种抽象的神经网络处理器编程语言翻译成底层的神经网络处理器指令序列。同时，通用编译器的编译流程包括：源代码$\rightarrow$预处理器$\rightarrow$编译器$\rightarrow$目标代码$\rightarrow$链接器$\rightarrow$可执行文件。对于编译过程，神经网络处理器编译器与传统编译器类似。但是，由于深度学习指令集的特殊性以及神经网络处理器结构的复杂性，在结构与储存层次方面，神经网络处理器编译器与传统编译器有很多不同。

\subsection{深度学习指令集的特性}
深度学习指令集(Cambricon)的特性主要是以下几点\cite{liu2016cambricon}：

1.数据并行度高。在大多数神经网络技术中，神经元和突触的数据被组织成层，然后以一个统一、对称的方式进行操作。为了适应这些操作，在数据集并行度方面，向量-矩阵(Vector/Matrix)指令比传统的标量指令的并行效率更高，因此Cambricon采用了矢量-矩阵指令进行设计，提高了数据的并行度。典型的例子就是应用于漏失(drop-out)的随机向量(Random-Vector)指令，用于在一条指令内部为一个向量进行快速随机初始化，以及应用于激活层的指数向量操作（Vector-Expotential），用于在一条指令内部为一个向量进行快速的非线性变换，而分支跳转的逻辑在神经网络计算任务里，并不像常规计算任务那么复杂，所以指令集的设计上并不需要提供丰富的分支跳转逻辑的支持。

2.定制矢量-矩阵指令。虽然有许多的线性代数库可以用于科学计算，但是对于神经网络计算来说，这些代数库中定义的操作并不一定是有效且高效的（有的甚至是多余的）。更重要的是，对于传统的线性代数库来说，很多操作不涉及神经网络技术，例如，BLAS库不支持元素的指数计算，也不支持随机向量在突触中的初始化、退出，因此，Cambricon以现有的线性代数库为基础，考虑神经网络技术，重新定制了一个具有小而具有代表性的向量-矩阵指令集。

3采用片上暂存存储器(On-chip Scratchpad memory)而不是寄存器堆来作为计算数据的主存储。由于神经网络技术的计算任务与常规的多媒体计算任务不同，往往需要访问并操作密集、连续、可改变长度的方式访问向量-矩阵数据。因此，使用固定宽度的寄存器不再是最有效且节约成本的选择。因此，Cambricon将向量寄存器替换为片上暂存缓存器，为每个数据的访问提供灵活的宽度。由于神经网络突触的数据量巨大，重复使用率高。而也会减少向量登记文件所带来的性能损失，使得网络数据并行度更加高效。

这些特性使得Cambricon指令集能正确的描述现在大部分的网络，同时，每条指令的描述能力高，对于描述同样的网络来说，所需的指令数量相比通用处理器要少很多。但，这也带来了缺陷，即便是同一条指令，对于不同的参数，指令的生存周期变化很大，且需要访问的存储方位也变化很大，不同类型的指令更是如此，更别说设计不同层次的存储访问。

\subsection{神经网络编译器与传统编译器的比较}
由于深度学习指令集的众多特性，这也使得神经网络编译器与传统编译器有很多不同。

首先，神经网络编译器对应编译的指令粒度较大，对于神经网络处理器来说，一条卷积(Conv)指令可以自己设置卷积核的大小、所需要的卷积图像大小，但是传统处理器的指令操作是固定的，这也给我们的验证带来了很多困难。

其次，神经网络编译器具有操作实现多样性的特点。同样的卷积，根据芯片资源不同，调度方式也不同，可能通过一条卷积指令实现，或者是多条卷积指令组合形式实现，十分复杂。

最后，神经网络编译器和传统编译器设计的存储层次也有很大不同，传统的编译器中，其计算指令都是针对寄存器的操作，只有load或者store才会涉及到寄存器数据和Cache或者RAM之间的数据交互，但神经网络编译器加入了中间存储这一层，改变了整个编译器的存储层次。

\subsection{使用测试框架带来的好处}
由于神经网络编译器的特殊性，若采用随机指令可能无法覆盖到实际使用需求的指令序列，所以需要实际的使用者，也就是编译器生成的指令来做二次检查，来寻找所有网络集合里那些不易覆盖的“Corner Case”。而测试框架是保证编译器和库这一整套系统正确性的环节，不可或缺。

\section{本节总结}
本节首先介绍了传统软件的测试方法，接着介绍了传统编译器的测试手段，通过分析深度学习指令集的特性，阐明了神经网络处理器编译器与传统编译器的差别，证明了神经网络处理器编译器测试框架的重要性。